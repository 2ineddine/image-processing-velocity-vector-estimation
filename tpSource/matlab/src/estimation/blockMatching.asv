function [u, v] = blockMatching( img1, img2, options )
% Estimation du mouvement par block matching
% Inputs:
%     - img1: image a t
%     - img2: image a t+1
%     - options: structure contenant des arguments supplementaires (optionel)
%         Les champs possibles (valeur par defaut) sont:
%         - dimB (2): 1/2 taille du bloc
%         - dimR (5): 1/2 hauteur de la zone de recherche
% Outputs:
%     - u, v: deplacement suivant x et y
% 
% Author: Thomas Dietenbeck

    dOptions = struct( 'dimB', 2, 'dimR', 5 );
    %-- Process inputs
    distance_vector = [];
    if( ~exist( 'options', 'var' ) )
        options = dOptions;
    elseif( ~isstruct( options ) )
        error( 'BlockMatching:Error', 'Options must be a struct' );
    else
        tags = fieldnames( dOptions );
        idxT = find( ~isfield( options, tags ) )';
        for i = idxT
            options.(tags{i}) = dOptions.(tags{i});
        end
    end
    dimB = options.dimB;
    dimR = options.dimR;
    sImg = size(img1);
    sX = sImg(1);           sY = sImg(2);
    u = zeros( sImg );      v = zeros( sImg );

    for x = dimB+1:sX-dimB     % Pour avoir la place du bloc
        for y = dimB+1:sY-dimB
            subR = img1( x-dimB:x+dimB, y-dimB:y+dimB );
            % dMin = flintmax;




            if mod(x,20)==0 && mod(y,20)==0  % every 20th pixel
                xStart = max(x-dimR,1); xEnd = min(x+dimR,sX);
                yStart = max(y-dimR,1); yEnd = min(y+dimR,sY);
                ROI = img2(xStart:xEnd, yStart:yEnd);

                figure(1); clf;
                subplot(1,2,1); imagesc(subR); colormap gray; axis image;
                title(['Reference Block at (',num2str(x),',',num2str(y),')']);
                subplot(1,2,2); imagesc(ROI); colormap gray; axis image;
                title('Search Region in img2');
                drawnow;
                pause(0.1);  % short pause to see the figure
            end
            subI = img2( x-dimB:x+dimB, y-dimB:y+dimB );
            dMin = getDistance( subR, subI );
            uTmp = 0;       vTmp = 0;
            for dX = -dimR:1:+dimR
                xP = x + dX;
                if( ((xP - dimB) >= 1) && ((xP + dimB) <= sX) )
                    for dY = -dimR:1:dimR
                        yP = y + dY;
                        if( ((yP - dimB) >= 1) && ((yP + dimB) <= sY) )
                            subI = img2( xP-dimB:xP+dimB, yP-dimB:yP+dimB );
                            d = getDistance( subR, subI );
                            if( d < dMin )
                                dMin = d;
                                uTmp = dX;
                                vTmp = dY;
                                distance_vector = [distance_vector,d];
                            end
                        end
                    end
                end
            end
            u(x, y) = uTmp;     v(x, y) = vTmp;
        end
    end
    maxi= max(distance_vector);mini = min(distance_vector);
    ten_per = (maxi)/10;
    disp(ten_per);




    function d = getDistance( subR, subI )
        d = sum( abs( subR(:) - subI(:) ) );	% MAD
        % d = sum( ( subR(:) - subI(:) ).^2 );    % MSSD

function [u, v] = blockMatching(img1, img2, options)
% Estimation du mouvement par block matching
% Inputs:
%     - img1: image à t
%     - img2: image à t+1
%     - options: structure avec arguments (dimB, dimR)
% Outputs:
%     - u, v: déplacement suivant x et y
%
% Visualization included: reference block, search region, motion vector

dOptions = struct('dimB', 2, 'dimR', 5);
distance_vector = [];

%-- Process options
if ~exist('options','var')
    options = dOptions;
elseif ~isstruct(options)
    error('Options must be a struct');
else
    tags = fieldnames(dOptions);
    idxT = find(~isfield(options, tags))';
    for i = idxT
        options.(tags{i}) = dOptions.(tags{i});
    end
end

dimB = options.dimB;
dimR = options.dimR;
sImg = size(img1);
sX = sImg(1); sY = sImg(2);
u = zeros(sImg); v = zeros(sImg);

stepVis = 20;  % adjust for speed of visualization
visX = []; visY = []; visU = []; visV = [];

for x = dimB+1:sX-dimB
    for y = dimB+1:sY-dimB
        subR = img1(x-dimB:x+dimB, y-dimB:y+dimB);
        dMin = getDistance(subR, img2(x-dimB:x+dimB, y-dimB:y+dimB));
        uTmp = 0; vTmp = 0;

        for dX = -dimR:dimR
            xP = x + dX;
            if xP - dimB < 1 || xP + dimB > sX, continue; end
            for dY = -dimR:dimR
                yP = y + dY;
                if yP - dimB < 1 || yP + dimB > sY, continue; end

                subI = img2(xP-dimB:xP+dimB, yP-dimB:yP+dimB);
                d = getDistance(subR, subI);
                if d < dMin
                    dMin = d;
                    uTmp = dX;
                    vTmp = dY;
                    distance_vector = [distance_vector, d];
                end
            end
        end

        u(x,y) = uTmp;
        v(x,y) = vTmp;

        % --- Visualization ---
        if mod(x, stepVis) == 0 && mod(y, stepVis) == 0 && (uTmp ~= 0 || vTmp ~= 0)
            xStart = max(x-dimR,1); xEnd = min(x+dimR,sX);
            yStart = max(y-dimR,1); yEnd = min(y+dimR,sY);
            ROI = img2(xStart:xEnd, yStart:yEnd);

            figure(1); clf;
            subplot(1,3,1); imagesc(subR); colormap gray; axis image; axis off;
            title(['Reference Block (',num2str(x),',',num2str(y),')']);

            subplot(1,3,2); imagesc(ROI); colormap gray; axis image; axis off;
            title('Search Region in img2');

            subplot(1,3,3); imagesc(img2); colormap gray; axis image; axis off; hold on;
            quiver(y, x, vTmp, uTmp, 'r', 'LineWidth', 1.5, 'MaxHeadSize', 2);
            rectangle('Position',[yStart, xStart, yEnd-yStart, xEnd-xStart], 'EdgeColor','b');
            title('Motion Vector + ROI');
            drawnow; pause(0.05);
        end

        % Store vectors for final quiver
        if mod(x, stepVis) == 0 && mod(y, stepVis) == 0
            visX(end+1) = x; visY(end+1) = y;
            visU(end+1) = uTmp; visV(end+1) = vTmp;
        end
    end
end

% --- Final visualization ---
figure; imagesc(img2); colormap gray; axis image; axis off; hold on;
quiver(visY, visX, visV, visU, 'r', 'LineWidth', 1.2, 'MaxHeadSize', 2);
title('Final Motion Vectors');

disp(['10% of max distance: ', num2str(max(distance_vector)/10)]);

%------------------------
    function d = getDistance(subR, subI)
        d = sum(abs(subR(:)-subI(:))); % MAD
    end

end
